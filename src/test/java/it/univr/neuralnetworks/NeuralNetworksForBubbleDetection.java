package it.univr.neuralnetworks;


import java.text.DecimalFormat;
import java.util.Arrays;
import java.util.Random;

import org.deeplearning4j.nn.conf.MultiLayerConfiguration;
import org.deeplearning4j.nn.conf.NeuralNetConfiguration;
import org.deeplearning4j.nn.conf.layers.DenseLayer;
import org.deeplearning4j.nn.conf.layers.OutputLayer;
import org.deeplearning4j.nn.multilayer.MultiLayerNetwork;
import org.nd4j.linalg.activations.Activation;
import org.nd4j.linalg.api.ndarray.INDArray;
import org.nd4j.linalg.dataset.DataSet;
import org.nd4j.linalg.factory.Nd4j;
import org.nd4j.linalg.learning.config.Adam;
import org.nd4j.linalg.lossfunctions.LossFunctions.LossFunction;

import it.univr.cevprices.CevPrices;

/**
 * This class uses the libraries deeplearning4j and nd4j in order to create and train a neural network which has to learn if
 * an underlying process is a strict local martingale (i.e., if it has a financial bubble) or a true martingale (i.e., it has
 * no bubble) based on the call prices it generates. 
 * In particular, here we consider processes X^i=(X^i_t)_{t >= 0} following the dynamics
 *   
 * dX^i_t = (X^i_t)^(beta_i),  (1)
 * X_0 = x_0,
 * 
 * where beta_i are random variables, uniformly distributed in and [0.5, 1.5]. These are CEV
 * models, and they are strict local martingales if and only if beta_i>1. In this example, we have sigma = 1.0 and x_0=2.
 * 
 * The call prices generated by this model can be computed analytically, and we do that in the class it.univr.cevprices.CevPrices.
 * We take 30 equally-spaced strikes between 0.5 and 10, and 50 equally-spaced maturities from 0.1 to 1.5.  
 * 
 * With these data, we train a neural network with 2 hidden layers of 200 and 100 nodes, respectively, giving it prices generated
 * in half cases by true martingale and in half cases by strict local martingales. We compute the weights and the biases via the
 * Adam algorithm with learning rate equal to 0.001 and 30 epochs. 
 * 
 * We then test it for prices generated by processes following (1) with other displacements and exponents. 
 * 
 * @author Andrea Mazzon
 *
 */
public class NeuralNetworksForBubbleDetection {

	public static void main(String[] args) {
			
		// FASE COSTRUZIONE NETWORK
		double learningRate = 0.001;
		int ourSeed = 1897;
		
		int numberOfStrikes = 30;
		int numberOfMaturities = 50;
		
		int numberOfNodesFirstHiddenLayer = 200;
		int numberOfNodesSecondHiddenLayer = 100;
		
		MultiLayerConfiguration layersConstruction = new NeuralNetConfiguration.Builder()
				.updater(new Adam(learningRate))//we specify how we want to update the optimal coefficients
				.seed(ourSeed) // we need a seed because the initial weights, the initial biases and the mini-batches are selected randomly
				.list()//now we want to specify the connections between the layers 
				//the following is the connection between input layer and first hidden layer:
				.layer(new DenseLayer.Builder()
						.nIn(numberOfStrikes*numberOfMaturities)//this is the number of inputs it receives
						.nOut(numberOfNodesFirstHiddenLayer) //this is the number of outputs: nodes of first hidden layer
						.activation(Activation.RELU)//it has ReLU activation function
						.build())
				//the following is the connection between first hidden layer and second hidden layer:
				.layer(new DenseLayer.Builder()
						.nIn(numberOfNodesFirstHiddenLayer)
						.nOut(numberOfNodesSecondHiddenLayer) 
						.activation(Activation.RELU)
						.build())
				//the following is the connection between the second hidden layer and the output layer:
				.layer(new OutputLayer.Builder()
						.nIn(numberOfNodesSecondHiddenLayer)
						.nOut(1) 
						/*
						 * It has sigmoid activation function: it means that it outputs a number that we can interpret as the
						 * probability that the input prices are generated by a strict local martingale
						 */
						.activation(Activation.SIGMOID)
						.lossFunction(LossFunction.XENT)//XENT is the cross-entropy loss function: often used for classification
						.build())
				.build();
		
		//we construct a neural network out of these layers..
		MultiLayerNetwork ourNetwork = new MultiLayerNetwork(layersConstruction);
		
		//..and we make it ready to be trained
		ourNetwork.init();
		
		//FASE DEFINIZIONE TRAINING SET
		
		double initialValueUnderlying = 2.0;
		double sigmaUnderlying = 0.3;
		
		//generation of strikes and maturities
		double smallestValueStrike = 0.5;
		double biggestValueStrike = 10;
		
		double smallestValueMaturity = 0.1;
		double biggestValueMaturity = 1.5;
		
		double[] strikes = new double[numberOfStrikes];
		double[] maturities = new double[numberOfMaturities];
		
		double strikeStep = (biggestValueStrike-smallestValueStrike)/(numberOfStrikes-1);
		double maturityStep = (biggestValueMaturity-smallestValueMaturity)/(numberOfMaturities-1);
		
		for (int i = 0; i < numberOfStrikes; i++) {
			strikes[i] = smallestValueStrike + i*strikeStep;
		}
		
		for (int j = 0; j < numberOfMaturities; j++) {
			maturities[j] = smallestValueMaturity + j*maturityStep;
		}
		
		
		int numberOfStrictLocalMartingalesForTraining = 100;
		int numberOfTrueMartingalesForTraining = 100;
		
		int numberOfRowsMatrixTraining = numberOfStrictLocalMartingalesForTraining+numberOfTrueMartingalesForTraining;
		
		//rows are prices generated by a given underlying, for all strikes and maturities
		double [][] pricesForTraining = new double[numberOfRowsMatrixTraining][numberOfStrikes*numberOfMaturities];
		
		//the interval where we generate the random exponents for the true martingales 
		double smallestExponentTrueMartingales = 0.5;
		double biggestExponentTrueMartingales = 1;
		
		//the interval where we generate the random exponents for the strict local martingales 
		double smallestExponentStrictLocalMartingales = 1.01;
		double biggestExponentStrictLocalMartingales = 1.5;
		
		Random randomGenerator = new Random();
		
		double differenceExponentsStrict = biggestExponentStrictLocalMartingales-smallestExponentStrictLocalMartingales;
		
		//all beta_i > 1
		for (int i = 0; i < numberOfStrictLocalMartingalesForTraining; i++ ){
			
			//generations of exponents in the interval of strict local martingales
			double randomNumber = randomGenerator.nextDouble();
			double exponent = smallestExponentStrictLocalMartingales+randomNumber*differenceExponentsStrict;

			//we compute the prices for the given exponent, and all combinations of strikes and maturities 
			for (int maturityIndex = 0; maturityIndex<numberOfMaturities; maturityIndex++) {
				for (int strikeIndex = 0; strikeIndex<numberOfStrikes; strikeIndex++) {
					double callPrice =
							CevPrices.CEVPriceCallForExponentBiggerThanOne(initialValueUnderlying, sigmaUnderlying, exponent, maturities[maturityIndex], strikes[strikeIndex]);
					pricesForTraining[i][maturityIndex*numberOfStrikes+strikeIndex] = callPrice;     
				}
			}		
		}

		double differenceExponentsTrue = biggestExponentTrueMartingales-smallestExponentTrueMartingales;


		//tutti beta_i <= 1
		for (int i = numberOfStrictLocalMartingalesForTraining; i < numberOfRowsMatrixTraining; i++ ){
			
			//generations of exponents in the interval of true martingales
			double randomNumber = randomGenerator.nextDouble();
			double exponent = smallestExponentTrueMartingales+randomNumber*differenceExponentsTrue;

			for (int maturityIndex = 0; maturityIndex<numberOfMaturities; maturityIndex++) {
				for (int strikeIndex = 0; strikeIndex<numberOfStrikes; strikeIndex++) {
					double callPrice =
							CevPrices.CEVPriceCallForExponentSmallerEqualOne(initialValueUnderlying, sigmaUnderlying, exponent, maturities[maturityIndex], strikes[strikeIndex]);
					pricesForTraining[i][maturityIndex*numberOfStrikes+strikeIndex] = callPrice;     
				}
			}		
		}
		
		/*
		 * They will be 1 for strict local martingales, 0 for martingales. So we hope that the network "learns the rule" that associates
		 * prices to these labels. We define it as a matrix with only one columns to make it compatible with the output of the network 
		 */
		double[][] labelsForTraining = new double[numberOfRowsMatrixTraining][1];
		
		for (int i = 0; i < numberOfStrictLocalMartingalesForTraining; i++ ){
			labelsForTraining[i][0] = 1;
		}

		for (int i = numberOfStrictLocalMartingalesForTraining; i < numberOfRowsMatrixTraining; i++ ){
			labelsForTraining[i][0] = 0;
		}
		
		//we transform the two matrices in objects that can be used to create a DataSet to train the network that we construct below
		INDArray pricesDataForTraining = Nd4j.create(pricesForTraining);
		INDArray labelsDataForTraining = Nd4j.create(labelsForTraining);

		DataSet trainingData = new DataSet(pricesDataForTraining, labelsDataForTraining);

		//FASE ADDESTRAMENTO DEL NETWORK
		
		int numberOfEpochs = 30;
		
		//we then train it iteratively, for any epoch
		for (int epochIndex = 0; epochIndex < numberOfEpochs; epochIndex++) {
			ourNetwork.fit(trainingData);
		}

		//FASE TEST
		
		int numberOfStrictLocalMartingalesForTesting = 10;
		int numberOfTrueMartingalesForTesting = 10;
		
		int numberOfRowsMatrixTesting = numberOfStrictLocalMartingalesForTesting+numberOfTrueMartingalesForTesting;
		
		double [][] pricesForTesting = 
				new double[numberOfRowsMatrixTesting][numberOfStrikes*numberOfMaturities];

		//tutti beta_i > 1
		for (int i = 0; i < numberOfStrictLocalMartingalesForTesting; i++ ){
			double randomNumber = randomGenerator.nextDouble();
			double exponent = smallestExponentStrictLocalMartingales+randomNumber*differenceExponentsStrict;

			for (int maturityIndex = 0; maturityIndex<numberOfMaturities; maturityIndex++) {
				for (int strikeIndex = 0; strikeIndex<numberOfStrikes; strikeIndex++) {
					double callPrice =
							CevPrices.CEVPriceCallForExponentBiggerThanOne(initialValueUnderlying, sigmaUnderlying, exponent, maturities[maturityIndex], strikes[strikeIndex]);
					pricesForTesting[i][maturityIndex*numberOfStrikes+strikeIndex] = callPrice;     
				}
			}		
		}

		//tutti beta_i <= 1
		for (int i = numberOfStrictLocalMartingalesForTesting; i < numberOfRowsMatrixTesting; i++ ){
			double randomNumber = randomGenerator.nextDouble();
			double exponent = smallestExponentTrueMartingales+randomNumber*differenceExponentsTrue;

			for (int maturityIndex = 0; maturityIndex<numberOfMaturities; maturityIndex++) {
				for (int strikeIndex = 0; strikeIndex<numberOfStrikes; strikeIndex++) {
					double callPrice =
							CevPrices.CEVPriceCallForExponentSmallerEqualOne(initialValueUnderlying, sigmaUnderlying, exponent, maturities[maturityIndex], strikes[strikeIndex]);
					pricesForTesting[i][maturityIndex*numberOfStrikes+strikeIndex] = callPrice;     
				}
			}		
		}
		
		
		INDArray pricesDataForTesting = Nd4j.create(pricesForTesting);
		//we get the the predictions of the network..
		INDArray predictionsAsINDArray = ourNetwork.output(pricesDataForTesting);

		//and we transform them into a double array
		double[] predictions = predictionsAsINDArray.toDoubleVector();
		
		System.out.println("Probabilities outputs that underlyings are strict local martingales");
		System.out.println(Arrays.toString(predictions));
	}

}
